#include <iostream>
using namespace std;

template <class T>
class Node
{
protected:
    T element;
    Node* nextptr;

public:
    Node(T i = 0, Node* pt = nullptr)
    {
        element = i;
        nextptr = pt;
    }

    T retrieve_n() const
    {
        return element;
    }
    Node<T>* next()
    {
        return nextptr;
    }
    template <class U>
    friend class List;
  
};

template <class T>
class List
{
private:
    Node<T>* head_list = nullptr;

public:

    bool empty() const
    {
        return head_list == nullptr;
    }

    void push_front(T n)
    {
        head_list = new Node<T>(n, head_list);
    }

    Node<T>* head()
    {
        return head_list;
    }

    void pop_front()
    {
        if (empty())
        {
            cout << "\nList is empty";
            return;
        }

        Node<T>* temp = head_list;
        T value = temp->element;

        head_list = head_list->nextptr;
        delete temp;

        
    }

    void push_end(T n)
    {
        Node<T>* newNode = new Node<T>(n);

        if (empty())
        {
            head_list = newNode;
            return;
        }

        Node<T>* ptr = head_list;
        while (ptr->nextptr != nullptr)
        {
            ptr = ptr->nextptr;
        }
        ptr->nextptr = newNode;
    }

    void pop_end()
    {
        if (empty())
        {
            cout << "\nList is empty";
            return;
        }

        if (head_list->nextptr == nullptr)
        {
            cout << "\nOnly one node. Deleting: " << head_list->element;
            delete head_list;
            head_list = nullptr;
            return;
        }

        Node<T>* ptr = head_list;
        while (ptr->nextptr->nextptr != nullptr)
        {
            ptr = ptr->nextptr;
        }

        cout << "\nDeleting last element: " << ptr->nextptr->element;
        delete ptr->nextptr;
        ptr->nextptr = nullptr;
    }

    void display() const
    {
        cout << "\nElements in the list:\n";
        for (Node<T>* ptr = head_list; ptr != nullptr; ptr = ptr->nextptr)
        {
            cout << ptr->element << "   ";
        }
        cout << endl;
    }

    T front() const
    {
        if (empty())
        {
            cout << "Empty!!";
            return T();   // default return value
        }

        return head_list->element;
    }

    int size()
    {
        int count = 0;
        for (Node<T>* ptr = head_list; ptr != nullptr; ptr = ptr->nextptr)
        {
            count++;
        }
        return count;
    }

    void count(T i)
    {
        int c = 0;
        for (Node<T>* ptr = head_list; ptr != nullptr; ptr = ptr->nextptr)
        {
            if (ptr->element == i)
                c++;
        }
        cout << "\nThe number " << i << " appears " << c << " times in the list";
    }

    void erase(T x)
    {
        if (empty()) return;

        while (head_list != nullptr && head_list->element == x)
        {
            Node<T>* temp = head_list;
            head_list = head_list->nextptr;
            delete temp;
        }

        Node<T>* ptr = head_list;
        while (ptr != nullptr && ptr->nextptr != nullptr)
        {
            if (ptr->nextptr->element == x)
            {
                Node<T>* temp = ptr->nextptr;
                ptr->nextptr = temp->nextptr;
                delete temp;
            }
            else
            {
                ptr = ptr->nextptr;
            }
        }

        cout << "\nAll occurrences of " << x << " deleted.";
    }
   
};

template <class T>
class Queue
{
public:
    List<T> li;

    bool empty()
    {
        return li.empty();
    }

    void push(T obj)
    {
        li.push_end(obj);
    }

    void pop()
    {
        if (empty())
        {
            cout << "\nQueue is empty!";
            return;
        }
        li.pop_front();
    }

    T top()
    {
        return li.front();
    }

    void show()
    {
        cout << "\nShowing the queue!\n";
        li.display();
    }
    
};

template <class t>
class Simple_tree
{
protected:
    t element; // the number we have stored 
    Simple_tree* parent_node;
    List <Simple_tree*> children; //why we have used *with simple_tree?
public:
    Simple_tree(t obj, Simple_tree* p = nullptr)
    {
        element = obj;
        parent_node = p;
    }

    t retrive()
    {
        return element;
    }

    Simple_tree* parent()
    {
        return parent_node;
    }

    Simple_tree* child(int n)//finding nth child of a tree 
    {
        if (n<0 || n>degree())
        {
            return nullptr;
        }
        Node<Simple_tree*>* ptr = children.head();
        for (int i = 1; i < n; i++)
        {
            ptr = ptr->next();
        }
        return ptr->retrieve_n();
    }

    int degree()// total number of chldrens
    {
        return children.size();
    }

    bool is_root()//having parent or not
    {
        return (parent() == nullptr);
    }

    bool is_leaf() //checking if having child or not
    {
        return (degree() == 0);
    }

    int size() //total number of nodes  counting
    {
        int s = 1; // for adding the parent node at the end 
        for (Node<Simple_tree*>* ptr = children.head(); ptr != nullptr; ptr = ptr->next())
        {
            s += ptr->retrieve_n()->size();
        }
        return s;
    }

    int height() //the depth of last node
    {
        int h = 0;
        for (Node<Simple_tree*>* ptr = children.head(); ptr != nullptr; ptr = ptr->next())
        {
            h = std::max(h, 1 + ptr->retrieve_n()->height());
        }
        return h;

    }
    void insert(t b) // a new node as a child
    {
        children.push_end(new Simple_tree(b, this));
        
    }

    void attatch(Simple_tree<t>* tree) //attatching a tree to another as a child 
    {
        if (!tree->is_root())
        {
            tree->detach(); //first detach from a tree if any 
        }
        tree->parent_node = this; // makes the child of the current parrent n the tree
        children.push_end(tree);
    }
    void detach()
    {
        if (is_root())
        {
            return;
        }
        parent()->children.erase(this);// erase curent child 
        parent_node = nullptr;
    }

    void depth_first_traversal() //deep down going to childs 
    {
       
        cout << retrive() << "\t";
        for (Node<Simple_tree*>* ptr = children.head(); ptr != nullptr; ptr = ptr->next())
        {
            ptr->retrieve_n()->depth_first_traversal();
        }
    }

    void breadth_first_traversal() 
    {
        cout << "\n Breadth First Traversal : ";
        Queue<Simple_tree*> q;
        q.push(this);

        while (!q.empty()) {
            Simple_tree* node = q.top();
            q.pop();
            cout << node->retrive();
            for (Node<Simple_tree*>* ptr = node->children.head(); ptr != nullptr; ptr = ptr->next())
            {
                q.push(ptr->retrieve_n());
            }
        }
    }
};
int main()
{
    Simple_tree<char> NameTree('Z');
    NameTree.insert('A');
    NameTree.insert('H');
   //first Inserting one side 
    Simple_tree<char>*NameTree2 =new Simple_tree<char>('R');
    NameTree2->insert('F');
    Simple_tree<char>*NameTree3 = new Simple_tree<char>('A');
    NameTree3->insert('A');
    NameTree.child(0)->attatch(NameTree2);
    NameTree.child(0)->attatch(NameTree3);

   // Inserting another side 
    Simple_tree<char>* NameTree4 = new Simple_tree<char>('T');
    NameTree2->insert('I');
    Simple_tree<char>* NameTree5 = new Simple_tree<char>('U');
    NameTree3->insert('L');
    NameTree.child(1)->attatch(NameTree4);
    NameTree.child(1)->attatch(NameTree5);
    cout << "\n Depth First Traversal : ";
    NameTree.depth_first_traversal();
    NameTree.breadth_first_traversal();
   cout<<"\n Height :"<< NameTree.height();
}
